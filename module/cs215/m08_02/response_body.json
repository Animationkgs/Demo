{"data":{"lesson":{"id":44424,"key":"48311840","title":"Problem Set 3 Solutions","semantic_type":"Lesson","is_public":true,"version":"1.0.0","locale":"en-us","summary":null,"lesson_type":"Classroom","display_workspace_project_only":null,"resources":{"files":[{"name":"Videos Zip File","uri":"http://d2uz2655q5g6b2.cloudfront.net/48311840/44424/1516978566135/Problem%20Set%203%20Solutions%20Videos.zip"},{"name":"Transcripts Zip File","uri":"http://d2uz2655q5g6b2.cloudfront.net/48311840/44424/1516978553807/Problem%20Set%203%20Solutions%20Subtitles.zip"}],"google_plus_link":null,"career_resource_center_link":null,"coaching_appointments_link":null,"office_hours_link":null,"aws_provisioning_link":null},"project":null,"lab":null,"concepts":[{"id":94350,"key":"487251870923","title":"Clustering Coefficient","semantic_type":"Concept","is_public":true,"user_state":{"node_key":"487251870923","completed_at":"2020-03-26T22:51:45.885Z","last_viewed_at":"2020-03-26T22:51:44.581Z","unstructured":null},"resources":null,"atoms":[{"id":42204,"key":"48725187","title":"Clustering Coefficient","semantic_type":"VideoAtom","is_public":true,"instructor_notes":null,"video":{"youtube_id":"bcxXlP5pe0U","china_cdn_id":"bcxXlP5pe0U.mp4","topher_id":"85628b02-d4a2-11e9-bb05-671aa0c43fcc","transcodings":{"uri_480p_mp4":"https://video.udacity-data.com/topher/2016/September/57d0a41d_clustering-coefficient-intro-to-algorithms/clustering-coefficient-intro-to-algorithms_480p.mp4","uri_720p_mp4":"https://video.udacity-data.com/topher/2016/September/57d0a41d_clustering-coefficient-intro-to-algorithms/clustering-coefficient-intro-to-algorithms_720p.mp4","uri_480p_1000kbps_mp4":"https://video.udacity-data.com/topher/2016/September/57d0a41d_clustering-coefficient-intro-to-algorithms/clustering-coefficient-intro-to-algorithms_480p_1000kbps.mp4"}}}]},{"id":71281,"key":"487400240923","title":"Bipartite I","semantic_type":"Concept","is_public":true,"user_state":{"node_key":"487400240923","completed_at":"2020-03-26T22:51:55.098Z","last_viewed_at":"2020-03-26T22:51:53.607Z","unstructured":null},"resources":null,"atoms":[{"id":34338,"key":"48740024","title":"Bipartite I","semantic_type":"VideoAtom","is_public":true,"instructor_notes":null,"video":{"youtube_id":"nouhvZHM-j8","china_cdn_id":"nouhvZHM-j8.mp4","topher_id":"8550e03c-d4a2-11e9-8f65-13fe63447119","transcodings":{"uri_480p_mp4":"https://video.udacity-data.com/topher/2016/September/57d1875c_bipartite-i-intro-to-algorithms/bipartite-i-intro-to-algorithms_480p.mp4","uri_720p_mp4":"https://video.udacity-data.com/topher/2016/September/57d1875c_bipartite-i-intro-to-algorithms/bipartite-i-intro-to-algorithms_720p.mp4","uri_480p_1000kbps_mp4":"https://video.udacity-data.com/topher/2016/September/57d1875c_bipartite-i-intro-to-algorithms/bipartite-i-intro-to-algorithms_480p_1000kbps.mp4"}}}]},{"id":1601,"key":"486836800923","title":"Bipartite II","semantic_type":"Concept","is_public":true,"user_state":{"node_key":"486836800923","completed_at":"2020-03-26T22:52:12.297Z","last_viewed_at":"2020-03-26T22:52:10.975Z","unstructured":null},"resources":null,"atoms":[{"id":97697,"key":"48683680","title":"Bipartite II","semantic_type":"VideoAtom","is_public":true,"instructor_notes":null,"video":{"youtube_id":"_QNcr7rhhPo","china_cdn_id":"_QNcr7rhhPo.mp4","topher_id":"8560f4b8-d4a2-11e9-bc5a-7bbce75f0994","transcodings":{"uri_480p_mp4":"https://video.udacity-data.com/topher/2016/September/57d50304_bipartite-ii-intro-to-algorithms/bipartite-ii-intro-to-algorithms_480p.mp4","uri_720p_mp4":"https://video.udacity-data.com/topher/2016/September/57d50304_bipartite-ii-intro-to-algorithms/bipartite-ii-intro-to-algorithms_720p.mp4","uri_480p_1000kbps_mp4":"https://video.udacity-data.com/topher/2016/September/57d50304_bipartite-ii-intro-to-algorithms/bipartite-ii-intro-to-algorithms_480p_1000kbps.mp4"}}}]},{"id":79785,"key":"486836790923","title":"Bipartite III","semantic_type":"Concept","is_public":true,"user_state":{"node_key":"486836790923","completed_at":"2020-03-26T22:52:19.052Z","last_viewed_at":"2020-03-26T22:52:17.734Z","unstructured":null},"resources":null,"atoms":[{"id":35183,"key":"48683679","title":"Bipartite III","semantic_type":"VideoAtom","is_public":true,"instructor_notes":null,"video":{"youtube_id":"WICHo62Hox8","china_cdn_id":"WICHo62Hox8.mp4","topher_id":"855f5540-d4a2-11e9-b7fb-7f0339f03dff","transcodings":{"uri_480p_mp4":"https://video.udacity-data.com/topher/2016/September/57d29587_bipartite-iii-intro-to-algorithms/bipartite-iii-intro-to-algorithms_480p.mp4","uri_720p_mp4":"https://video.udacity-data.com/topher/2016/September/57d29587_bipartite-iii-intro-to-algorithms/bipartite-iii-intro-to-algorithms_720p.mp4","uri_480p_1000kbps_mp4":"https://video.udacity-data.com/topher/2016/September/57d29587_bipartite-iii-intro-to-algorithms/bipartite-iii-intro-to-algorithms_480p_1000kbps.mp4"}}}]},{"id":110338,"key":"487380390923","title":"Bipartite IV","semantic_type":"Concept","is_public":true,"user_state":{"node_key":"487380390923","completed_at":"2020-03-26T22:52:24.247Z","last_viewed_at":"2020-03-26T22:52:22.950Z","unstructured":null},"resources":null,"atoms":[{"id":18355,"key":"48738039","title":"Bipartite IV","semantic_type":"VideoAtom","is_public":true,"instructor_notes":null,"video":{"youtube_id":"9rXWs0pxewQ","china_cdn_id":"9rXWs0pxewQ.mp4","topher_id":"85350cc2-d4a2-11e9-963e-539152e3edf9","transcodings":{"uri_480p_mp4":"https://video.udacity-data.com/topher/2016/September/57d09b64_bipartite-iv-intro-to-algorithms/bipartite-iv-intro-to-algorithms_480p.mp4","uri_720p_mp4":"https://video.udacity-data.com/topher/2016/September/57d09b64_bipartite-iv-intro-to-algorithms/bipartite-iv-intro-to-algorithms_720p.mp4","uri_480p_1000kbps_mp4":"https://video.udacity-data.com/topher/2016/September/57d09b64_bipartite-iv-intro-to-algorithms/bipartite-iv-intro-to-algorithms_480p_1000kbps.mp4"}}}]},{"id":106385,"key":"487251860923","title":"Mark Component","semantic_type":"Concept","is_public":true,"user_state":{"node_key":"487251860923","completed_at":"2020-03-26T22:52:29.163Z","last_viewed_at":"2020-03-26T22:52:27.842Z","unstructured":null},"resources":null,"atoms":[{"id":77826,"key":"48725186","title":"Mark Component","semantic_type":"VideoAtom","is_public":true,"instructor_notes":"Similar to breadth first search, the main difference between DFS and BFS is the order in which nodes\nare removed from the open list.\n\n    def mark_component(G, node, marked):\n        open_list = [node]\n        total_marked = 1\n        marked[node] = True\n        while len(open_list) > 0:\n            node = open_list.pop()\n            for neighbor in G[node]:\n                if neighbor not in marked:\n                    open_list.append(neighbor)\n                    marked[neighbor] = True\n                    total_marked += 1\n        return total_marked","video":{"youtube_id":"UiLV_SPCVdY","china_cdn_id":"UiLV_SPCVdY.mp4","topher_id":"855d9f66-d4a2-11e9-b30d-b304f3b91262","transcodings":{"uri_480p_mp4":"https://video.udacity-data.com/topher/2016/September/57d27b06_bridge-edges-intro-to-algorithms/bridge-edges-intro-to-algorithms_480p.mp4","uri_720p_mp4":"https://video.udacity-data.com/topher/2016/September/57d27b06_bridge-edges-intro-to-algorithms/bridge-edges-intro-to-algorithms_720p.mp4","uri_480p_1000kbps_mp4":"https://video.udacity-data.com/topher/2016/September/57d27b06_bridge-edges-intro-to-algorithms/bridge-edges-intro-to-algorithms_480p_1000kbps.mp4"}}}]},{"id":90447,"key":"487410190923","title":"Centrality","semantic_type":"Concept","is_public":true,"user_state":{"node_key":"487410190923","completed_at":"2020-03-26T22:52:33.624Z","last_viewed_at":"2020-03-26T22:52:32.352Z","unstructured":null},"resources":null,"atoms":[{"id":34752,"key":"48741019","title":"Centrality","semantic_type":"VideoAtom","is_public":true,"instructor_notes":"Similar to the centrality algorithm given in class, except this takes the maximum of the distances in distance_from_start instead of the average.\n\n    def centrality_max(G, v):\n        distance_from_start = {}\n        open_list = [v]\n        distance_from_start[v] = 0\n        while len(open_list) > 0:\n            current = open_list[0]\n            del open_list[0]\n            for neighbor in G[current].keys():\n                if neighbor not in distance_from_start:\n                    distance_from_start[neighbor] = distance_from_start[current] + 1\n                    open_list.append(neighbor)\n        return max(distance_from_start.values())\n        ","video":{"youtube_id":"UiLV_SPCVdY","china_cdn_id":"UiLV_SPCVdY.mp4","topher_id":"855d9f66-d4a2-11e9-b30d-b304f3b91262","transcodings":{"uri_480p_mp4":"https://video.udacity-data.com/topher/2016/September/57d27b06_bridge-edges-intro-to-algorithms/bridge-edges-intro-to-algorithms_480p.mp4","uri_720p_mp4":"https://video.udacity-data.com/topher/2016/September/57d27b06_bridge-edges-intro-to-algorithms/bridge-edges-intro-to-algorithms_720p.mp4","uri_480p_1000kbps_mp4":"https://video.udacity-data.com/topher/2016/September/57d27b06_bridge-edges-intro-to-algorithms/bridge-edges-intro-to-algorithms_480p_1000kbps.mp4"}}}]},{"id":88104,"key":"487135360923","title":"Bridge Edges","semantic_type":"Concept","is_public":true,"user_state":{"node_key":"487135360923","completed_at":"2020-03-26T22:52:39.350Z","last_viewed_at":"2020-03-26T22:52:38.035Z","unstructured":null},"resources":null,"atoms":[{"id":38417,"key":"48713536","title":"Bridge Edges","semantic_type":"VideoAtom","is_public":true,"instructor_notes":"    #\n    # First some utility functions\n    #\n    \n    def make_link(G, node1, node2, r_or_g):\n        # modified make_link to apply\n        # a color to the edge instead of just 1\n        if node1 not in G:\n            G[node1] = {}\n        (G[node1])[node2] = r_or_g\n        if node2 not in G:\n            G[node2] = {}\n        (G[node2])[node1] = r_or_g\n        return G\n    \n    def get_children(S, root, parent):\n        \"\"\"returns the children from following the\n        green edges\"\"\"\n        return [n for n, e in S[root].items()\n                if ((not n == parent) and\n                    (e == 'green'))]\n    \n    def get_children_all(S, root, parent):\n        \"\"\"returns the children from following\n        green edges and the children from following\n        red edges\"\"\"\n        green = []\n        red = []\n        for n, e in S[root].items():\n            if n == parent:\n                continue\n            if e == 'green':\n                green.append(n)\n            if e == 'red':\n                red.append(n)\n        return green, red\n    \n    #################\n    \n    def create_rooted_spanning_tree(G, root):\n        # use DFS from the root to add edges and nodes\n        # to the tree.  The first time we see a node\n        # the edge is green, but after that its red\n        open_list = [root]\n        S = {root:{}}\n        while len(open_list) > 0:\n            node = open_list.pop()\n            neighbors = G[node]\n            for n in neighbors:\n                if n not in S:\n                    # we haven't seen this node, so\n                    # need to use a green edge to connect\n                    # it\n                    make_link(S, node, n, 'green')\n                    open_list.append(n)\n                else:\n                    # we have seen this node,\n                    # but, first make sure that \n                    # don't already have the edge\n                    # in S\n                    if node not in S[n]:\n                        make_link(S, node, n, 'red')\n        return S\n    \n    ##################\n    \n    def _post_order(S, root, parent, val, po):\n        children = get_children(S, root, parent)    \n        for c in children:\n            val = _post_order(S, c, root, val, po)\n        po[root] = val\n        return val + 1\n    \n    def post_order(S, root):\n        po = {}\n        _post_order(S, root, None, 1, po)\n        return po\n    \n    \n    ##################\n    \n    def _number_descendants(S, root, parent, nd):\n        # number of descendants is the \n        # sum of the number of descendants of a nodes\n        # children plus one\n        children = get_children(S, root, parent)\n        nd_val = 1\n        for c in children:\n            # recursively calculate the number of descendants\n            # for the children\n            nd_val += _number_descendants(S, c, root, nd)\n        nd[root] = nd_val\n        return nd_val\n    \n    def number_of_descendants(S, root):\n        nd = {}\n        _number_descendants(S, root, None, nd)\n        return nd\n    \n    \n    #\n    # Since highest and lowest post order will follow\n    # a similar method, I only wrote one method\n    # that can be used for both\n    #\n    def _general_post_order(S, root, parent, po, gpo, comp):\n        green, red = get_children_all(S, root, parent)\n        val = po[root]\n        for c in green:\n            # recursively find the low/high post order value of the children\n            test = _general_post_order(S, c, root, po, gpo, comp)\n            # and save the low/highest one\n            if comp(val, test):\n                val = test\n        for c in red:\n            test = po[c]\n            # and also look at the direct children\n            # from following red edges\n            # and save the low/highest one if needed\n            if comp(val, test):\n                val = test\n        gpo[root] = val\n        return val\n    \n    def lowest_post_order(S, root, po):\n        lpo = {}\n        _general_post_order(S, root, None, po, lpo, lambda x, y: x > y) \n        return lpo\n    \n    def highest_post_order(S, root, po):\n        hpo = {}\n        _general_post_order(S, root, None, po, hpo, lambda x, y: x < y)\n        return hpo\n    \n    #\n    # Now put everything together\n    #\n    \n    def bridge_edges(G, root):\n        S = create_rooted_spanning_tree(G, root)\n        po = post_order(S, root)\n        nd = number_of_descendants(S, root)\n        lpo = lowest_post_order(S, root, po)\n        hpo = highest_post_order(S, root, po)\n        bridges = []\n        open_list = [(root, None)]\n        # walk down the tree and see which edges are\n        # tree edges\n        while len(open_list) > 0:\n            node, parent = open_list.pop()\n            for child in get_children(S, node, parent):\n                # all of these edges are automatically green (get_children only\n                # follows green edges)\n                # so only need to check the other two conditions\n                if hpo[child] <= po[child] and lpo[child] > (po[child] - nd[child]):\n                    bridges.append((node, child))\n                open_list.append((child, node))\n        return bridges","video":{"youtube_id":"UiLV_SPCVdY","china_cdn_id":"UiLV_SPCVdY.mp4","topher_id":"855d9f66-d4a2-11e9-b30d-b304f3b91262","transcodings":{"uri_480p_mp4":"https://video.udacity-data.com/topher/2016/September/57d27b06_bridge-edges-intro-to-algorithms/bridge-edges-intro-to-algorithms_480p.mp4","uri_720p_mp4":"https://video.udacity-data.com/topher/2016/September/57d27b06_bridge-edges-intro-to-algorithms/bridge-edges-intro-to-algorithms_720p.mp4","uri_480p_1000kbps_mp4":"https://video.udacity-data.com/topher/2016/September/57d27b06_bridge-edges-intro-to-algorithms/bridge-edges-intro-to-algorithms_480p_1000kbps.mp4"}}}]}]}}}